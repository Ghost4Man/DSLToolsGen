using Antlr4Ast;

using VisitorPatternGenerator;

namespace DSLToolsGenerator.Models;

public partial interface IModel;

[Visitor<IModel>(voidReturn: true)]
public partial interface IModelVisitor;

[Visitor<IModel>(voidReturn: true)]
public partial interface IModelVisitor<in TArg>;

[Acceptor<IModel>]
public partial record AstCodeModel(IList<NodeClassModel> NodeClasses, AstBuilderModel AstBuilder) : IModel;

[Acceptor<IModel>]
public abstract partial record PropertyModel(string Name) : IModel;

[Acceptor<IModel>]
public partial record NodeReferencePropertyModel(string Name, NodeClassModel NodeClass, bool Optional) : PropertyModel(Name);

[Acceptor<IModel>]
public partial record NodeReferenceListPropertyModel(string Name, NodeClassModel NodeClass) : PropertyModel(Name);

[Acceptor<IModel>]
public partial record TokenTextPropertyModel(string Name, ResolvedTokenRef Token, bool Optional) : PropertyModel(Name);

[Acceptor<IModel>]
public partial record TokenTextListPropertyModel(string Name, ResolvedTokenRef Token) : PropertyModel(Name);

[Acceptor<IModel>]
public partial record OptionalTokenPropertyModel(string Name, ResolvedTokenRef Token) : PropertyModel(Name);

[Acceptor<IModel>]
public partial record NodeClassModel(string Name, Rule ParserRule, IList<PropertyModel> Properties) : IModel
{
    NodeClassModel? _baseClass;
    readonly IReadOnlyList<NodeClassModel> _variants = [];

    public NodeClassModel? BaseClass { get => _baseClass; init => _baseClass = value; }

    public IReadOnlyList<NodeClassModel> Variants
    {
        get => _variants;
        init
        {
            _variants = value;
            // initialize the base class of the variant classes to point to this class model
            // (because we can't construct the base class before we have constructed the variants,
            // but to construct the variants, we need a reference to the base class)
            foreach (var variantClass in _variants)
            {
                variantClass._baseClass = this;
            }
        }
    }
}

/// <summary>
/// Model of an AstBuilder class, which is a Visitor pattern implementation
/// that converts parse trees (created by ANTLR-generated parsers) to ASTs.
/// </summary>
/// <param name="AntlrGrammarName">Name of the input grammar (used by ANTLR to generate names of listeners, visitors, etc.), e.g. "Foo" or "FooParser"</param>
/// <param name="ParserClassName">Name of the parser class generated by ANTLR, e.g. "FooParser"</param>
/// <param name="AstMapping"></param>
[Acceptor<IModel>]
public partial record AstBuilderModel(string AntlrGrammarName, string ParserClassName, IList<AstMappingModel> AstMapping) : IModel
{
    public string GetRuleContextClassName(Rule rule)
    {
        return $"{ParserClassName}.{rule.Name.Capitalize()}Context";
    }
}

public record AstMappingModel(Rule Rule, NodeClassModel Ast);

public record ResolvedTokenRef(string? Name, Literal? Literal, Rule? LexerRule);
