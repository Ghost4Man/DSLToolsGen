using Antlr4Ast;

using VisitorPatternGenerator;

namespace DSLToolsGenerator.AST.Models;

public partial interface IModel;

[Visitor<IModel>(voidReturn: true)]
public partial interface IModelVisitor;

[Visitor<IModel>(voidReturn: true)]
public partial interface IModelVisitor<in TArg>;

[Acceptor<IModel>]
public partial record AstCodeModel(IList<NodeClassModel> NodeClasses, AstBuilderModel AstBuilder) : IModel
{
    public IEnumerable<NodeClassModel> GetAllNodeClasses()
        => NodeClasses.SelectMany(nc => nc.GetAllSubclassesAndSelf());
}

[Acceptor<IModel>]
public abstract partial record PropertyModel(string Name, ContextChildAccess Source) : IModel;

[Acceptor<IModel>]
public partial record NodeReferencePropertyModel(string Name, ContextChildAccess Source,
    // The Lazy is needed so that we don't get stuck while
    // fetching references to self (or mutual rule references).
    // This assumes we only access the NodeClass property after all NodeClasses are generated
    Lazy<NodeClassModel> NodeClass,
    bool Optional
    ) : PropertyModel(Name, Source);

[Acceptor<IModel>]
public partial record NodeReferenceListPropertyModel(string Name, ContextChildAccess Source,
    Lazy<NodeClassModel> NodeClass) : PropertyModel(Name, Source);

[Acceptor<IModel>]
public partial record TokenTextPropertyModel(string Name, ContextChildAccess Source,
    bool Optional) : PropertyModel(Name, Source);

[Acceptor<IModel>]
public partial record TokenTextListPropertyModel(string Name, ContextChildAccess Source)
    : PropertyModel(Name, Source);

[Acceptor<IModel>]
public partial record OptionalTokenPropertyModel(string Name, ContextChildAccess Source)
    : PropertyModel(Name, Source);

[Acceptor<IModel>]
public partial record NodeClassModel(string Name, Rule ParserRule, Alternative? SourceAlt, IList<PropertyModel> Properties) : IModel
{
    NodeClassModel? _baseClass;
    readonly IReadOnlyList<NodeClassModel> _variants = [];

    public NodeClassModel? BaseClass { get => _baseClass; init => _baseClass = value; }

    public IReadOnlyList<NodeClassModel> Variants
    {
        get => _variants;
        init
        {
            _variants = value;
            // initialize the base class of the variant classes to point to this class model
            // (because we can't construct the base class before we have constructed the variants,
            // but to construct the variants, we need a reference to the base class)
            foreach (var variantClass in _variants)
            {
                variantClass._baseClass = this;
            }
        }
    }

    /// <summary>
    /// Returns a value indicating whether this node class is abstract, i.e. it has
    /// concrete subclasses (<see cref="Variants"/>) that correspond to rule alternatives.
    /// </summary>
    public bool IsAbstract => Variants.Count > 0;

    // Visit{SourceContextName}, FooParser.{SourceContextName}Context, etc.
    public string SourceContextName => (SourceAlt?.ParserLabel ?? ParserRule.Name).Capitalize();

    // e.g. type : simpleType | arrayType | functionType ;
    public bool HasUnlabeledVariants => Variants.Any(v => v.SourceAlt?.ParserLabel is null);

    public IEnumerable<NodeClassModel> GetAllSubclassesAndSelf()
        => Variants.SelectMany(nc => nc.GetAllSubclassesAndSelf()).Prepend(this);
}

/// <summary>
/// Model of an AstBuilder class, which is a Visitor pattern implementation
/// that converts parse trees (created by ANTLR-generated parsers) to ASTs.
/// </summary>
/// <param name="AntlrGrammarName">Name of the input grammar (used by ANTLR to generate names of listeners, visitors, etc.), e.g. "Foo" or "FooParser"</param>
/// <param name="ParserClassName">Name of the parser class generated by ANTLR, e.g. "FooParser"</param>
/// <param name="AstMapping"></param>
[Acceptor<IModel>]
public partial record AstBuilderModel(string AntlrGrammarName, string ParserClassName, IList<AstMappingModel> AstMapping) : IModel;

public record AstMappingModel(Rule Rule, NodeClassModel Ast);

/// <summary>
/// Describes a way to access a specific child node of a <c>ParserRuleContext</c>.
/// </summary>
public abstract record ContextChildAccess
{
    private ContextChildAccess() { }

    public sealed record ByLabel(string Label, LabelKind Kind) : ContextChildAccess;
    public sealed record Getter(string RuleOrTokenName, int? Index = null) : ContextChildAccess;

    /// <summary>
    /// Access an unnamed token (from an implicit literal in the grammar),
    /// e.g. <c>'if'</c> without a corresponding <c>IF : 'if' ;</c> rule.
    /// </summary>
    /// <param name="LiteralValue">The actual value represented by the literal, without single quotes and escape sequences.
    ///     See <see cref="LiteralExtensions.GetUnescapedValue(Literal)"/>.</param>
    public sealed record ByText(string LiteralValue, int? Index = null) : ContextChildAccess;

    public static ContextChildAccess For(SyntaxElement element, string ruleOrTokenName, bool list)
    {
        if (element.Label is not null)
            return new ByLabel(element.Label, element.LabelKind);

        return (element, ruleOrTokenName) switch {
            (_, not null) => new Getter(ruleOrTokenName, getElementMappingIndex()),
            (Literal literal, _) => new ByText(literal.GetUnescapedValue(), getElementMappingIndex()),
            _ => throw new ArgumentNullException(nameof(ruleOrTokenName)),
        };

        // e.g. emit code like `context.expr()` instead of `context.expr(0)`
        // if the element is the only reference to the `expr` rule in `context`
        // or is part of a delimited list like `expr (',' expr)+`
        int? getElementMappingIndex() => (list || element.IsOnlyOfType())
            ? null
            : element.GetElementIndex().IndexByType;
    }
}
